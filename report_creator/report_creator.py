import logging
import re
import textwrap
import traceback
from typing import Optional
from pathlib import Path

# Visualization
import humanize
import matplotlib as mpl
import plotly.io as pio
from cycler import cycler

# Templating & formatting
from jinja2 import Environment, FileSystemLoader

# Internal imports
from .components import (
    Base,
    Block,
    Group,
)
from .theming import get_rc_theme, report_creator_colors
from .utilities import (
    _convert_filepath_to_datauri,
    _gfm_markdown_to_html,
    _time_it,
)

# Configure logging
logger = logging.getLogger("report_creator")
logging.getLogger("urllib3").setLevel(logging.WARNING)
logging.getLogger("matplotlib.font_manager").setLevel(logging.WARNING)

# Define the base directory for templates relative to this file
TEMPLATE_DIR = Path(__file__).parent / "templates"


class ReportCreator:
    """
    Generates interactive HTML reports from structured Python data.

    # ... (rest of the extensive docstring remains the same) ...

    Args:
        title (str): The title of the report.
        description (str, optional): The description of the report (markdown is ok). Defaults to None.
        author (str, optional): The author of the report. Defaults to None.
        logo (Optional[str | Path], optional): A GitHub username, a url/filepath (str or Path) to an image, or None. Defaults to None,
            which will use an autogenerated icon based on the title.
        theme (str, optional): The theme to use for the report. Defaults to "rc".
        code_theme (str, optional): The theme for code highlighting. Defaults to "github-dark".
        diagram_theme (str, optional): The mermaid theme to use.
            Options: "default", "neo", "neo-dark", "dark", "neutral", "forest", & "base". Defaults to "default".
        accent_color (str, optional): The accent color for the report. Defaults to "black".
        footer (str, optional): The footer text for the report (markdown is ok). Defaults to None.
    """

    def __init__(
        self,
        title: str,
        *,
        description: Optional[str] = None,
        author: Optional[str] = None,
        logo: Optional[str | Path] = None, # Allow Path for logo
        theme: str = "rc",
        code_theme: str = "github-dark",
        diagram_theme: str = "default",
        accent_color: str = "black",
        footer: Optional[str] = None,
    ):
        self.title = title
        self.description = description
        self.author = author
        self.code_theme = code_theme
        self.diagram_theme = diagram_theme
        self.accent_color = accent_color
        self.footer = footer

        logger.info(f"ReportCreator: {self.title=} {self.description=}")

        # Setup plotting template
        pio.templates["rc"] = get_rc_theme()

        # Validate theme
        valid_themes = list(pio.templates.keys())
        if theme not in valid_themes:
             # Use ValueError for invalid configuration parameters
             raise ValueError(
                 f"Theme '{theme}' not in available themes: {', '.join(valid_themes)}"
             )
        pio.templates.default = theme

        self._create_header(logo)

    def _create_header(self, logo: Optional[str | Path]) -> None:
        """Create the header icon or logo for the report."""
        logo_style = 'style="width: 125px;"' # Define style once
        if logo:
            if isinstance(logo, str) and logo.startswith(("http", "data:image")):
                self.header_str = f'<img src="{logo}" {logo_style}>'
            elif isinstance(logo, (str, Path)):
                logo_path = Path(logo)
                if logo_path.is_file():
                    try:
                        data_uri = _convert_filepath_to_datauri(logo_path)
                        self.header_str = f'<img src="{data_uri}" {logo_style}>'
                    except Exception as e:
                        logger.warning(f"Could not convert logo path {logo_path} to data URI: {e}. Skipping logo.")
                        self.header_str = "" # Fallback to no logo if conversion fails
                elif isinstance(logo, str): # Check if it might be a GitHub username (only if it's a string)
                     logger.info(f"Assuming '{logo}' is a GitHub username for logo.")
                     self.header_str = f'<img src="https://avatars.githubusercontent.com/{logo}?s=125" {logo_style}>'
                else:
                    logger.warning(f"Logo path '{logo}' not found or invalid type. Skipping logo.")
                    self.header_str = "" # Fallback if path invalid and not a known string pattern
            else:
                 logger.warning(f"Invalid logo type: {type(logo)}. Skipping logo.")
                 self.header_str = "" # Fallback for unexpected type
        else:
            # Create an icon from the report title
            match = re.findall(r"[A-Z]", self.title)
            icon_text = "".join(match[:2]) if match else self.title[0].upper() # Ensure uppercase for single initial
            icon_color, text_color = self.accent_color, "white"

            width = 150
            cx = width / 2
            cy = width / 2
            r = width / 2
            fs = int(r)

            self.header_str = textwrap.dedent(f"""\
                <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="{width}" height="{width}">
                    <style>
                        .icon_text_style {{
                            font-size: {fs}px;
                            stroke-width: 1px;
                            font-family: sans-serif;
                            font-weight: bold;
                            text-anchor: middle;
                            dominant-baseline: central;
                        }}
                    </style>
                    <circle cx="{cx}" cy="{cy}" r="{r}" fill="{icon_color}" />
                    <text class="icon_text_style" x="50%" y="50%" fill="{text_color}">{icon_text}</text>
                </svg>
            """)

    def __enter__(self):
        """
        Enter context: Save the original Matplotlib color cycle and apply report colors.
        This ensures any Matplotlib figures generated during report creation use the report's theme colors.
        """
        self.default_colors = mpl.rcParams["axes.prop_cycle"].by_key()["color"]
        mpl.rcParams["axes.prop_cycle"] = cycler("color", report_creator_colors)
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        """Exit context: Restore the original Matplotlib color cycle."""
        mpl.rcParams["axes.prop_cycle"] = cycler("color", self.default_colors)

    @_time_it
    def save(self, view: Base, path: str | Path, prettify_html: bool = True) -> None:
        """
        Save the report to a file.

        Args:
            view (Base): The view object representing the report content (typically Block or Group).
            path (str | Path): The path (string or Path object) to save the report file.
            prettify_html (bool, optional): Whether to prettify the generated HTML using BeautifulSoup.
                                           Requires `beautifulsoup4` to be installed. Defaults to True.

        Raises:
            ValueError: If the view object is not an instance of Base (or specifically Block/Group if needed).
            FileNotFoundError: If the template file cannot be found.
            Exception: Can raise exceptions from view.to_html() or file I/O.
        """
        output_path = Path(path)

        if not isinstance(view, Base): # Check against the base class
            raise ValueError(
                f"Expected view to be an instance of Base component, got {type(view).__name__} instead"
            )


        logger.info(f"Rendering report content...")
        try:
            body = view.to_html()
        except Exception:
            # Log the error and include traceback in the report body for debugging
            error_trace = traceback.format_exc()
            logger.error(f"Error rendering report view: {error_trace}")
            body = f"<h1>Error Rendering Report Content</h1><pre>{error_trace}</pre>"

        # Load the Jinja2 template
        try:
            file_loader = FileSystemLoader(str(TEMPLATE_DIR)) # Use the Path object, converted to str
            env = Environment(loader=file_loader, autoescape=False) 
            template = env.get_template("default.html")
        except Exception as e:
             logger.error(f"Failed to load report template from {TEMPLATE_DIR}: {e}")
             raise FileNotFoundError(f"Could not load report template: {e}") from e

        # Determine which libraries to include (keep string checking for now)
        include_plotly = "plotly-graph-div" in body
        include_datatable = "include_datatable" in body
        include_mermaid = "include_mermaid" in body
        include_hljs = "include_hljs" in body

        logger.info(
            f"Report features detected: {include_plotly=}, {include_datatable=}, {include_mermaid=}, {include_hljs=}"
        )
        logger.info(
            f"Report metadata: {self.description=}, {self.author=} {prettify_html=}"
        )

        # Render the final HTML
        try:
            html = template.render(
                title=self.title or "Report",
                description=_gfm_markdown_to_html(self.description) if self.description else "",
                author=self.author.strip() if self.author else "",
                body=body,
                header_logo=self.header_str,
                include_plotly=include_plotly,
                include_datatable=include_datatable,
                include_mermaid=include_mermaid,
                include_hljs=include_hljs,
                code_theme=self.code_theme,
                diagram_theme=self.diagram_theme,
                accent_color=self.accent_color,
                footer=_gfm_markdown_to_html(self.footer).strip() if self.footer else None,
            )
        except Exception as e:
            logger.error(f"Failed to render final HTML template: {e}")
            # Provide a fallback HTML or raise error
            raise RuntimeError(f"Failed during final HTML template rendering: {e}") from e


        # Prettify if requested and possible
        if prettify_html:
            try:
                from bs4 import BeautifulSoup
                # Use 'html.parser' for built-in, 'lxml' or 'html5lib' for potentially better parsing
                soup = BeautifulSoup(html, "html.parser")
                # formatter="minimal" avoids adding extra newlines within tags
                # Use soup.prettify() for standard indentation
                output_content = soup.prettify(formatter="minimal")
            except ImportError:
                logger.warning("BeautifulSoup not installed (`pip install beautifulsoup4`), saving HTML without prettification.")
                output_content = html
            except Exception as e:
                logger.warning(f"HTML prettification failed: {e}. Saving raw HTML.")
                output_content = html
        else:
            output_content = html

        # Save the HTML to file using pathlib
        try:
            # Ensure parent directory exists
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(output_content, encoding="utf-8")
            file_size = output_path.stat().st_size
            logger.info(
                f'ReportCreator successfully created {output_path} '
                f'(size: {humanize.naturalsize(file_size, binary=True)}, title: "{self.title}")'
            )
        except (IOError, OSError) as e:
            logger.error(f"Failed to write report file to {output_path}: {e}")
            raise IOError(f"Failed to write report file: {e}") from e